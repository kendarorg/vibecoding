### REQ 001

<step>
Create a php class called FlatStorage that
* Uses two files as "indexes"
	* "structure/index.log": contains a list of items in format ACTION,ITEM_UUID,PARENT_UUID
	* "structure/names.log": contains a list of items in format ACTION,ITEM_UUID,ITEM_TITLE
* The data will be stored under the directory "data"
* The root item uuid is '00000000-0000-0000-0000-000000000000' with name 'Root'
* The root item is fixed, not modifiable, not deletable and not stored on indexes.
</step>
<step>
Expose these methods
* upsertItem(ITEM_UUID,PARENT_UUID,ITEM_TITLE,ITEM_CONTENT)
	* If the file "data/ITEM_UUID" does not exists
		* Create the file "data/ITEM_UUID" with content ITEM_CONTENT
		* Add on "structure/index.log" a line CR,ITEM_UUID,PARENT_UUID
		* Add on "structure/names.log" a line CR,ITEM_UUID,ITEM_TITLE
	* Else if the file "data/ITEM_UUID" exists
		* If the last line with matching ITEM_UUID in "structure/index.log" has a different PARENT_UUID
			* Add on "structure/index.log" a line MV,ITEM_UUID,PARENT_UUID
		* If the last line with matching ITEM_UUID in "structure/names.log" has a different ITEM_TITLE
			* Add on "structure/names.log" a line RN,ITEM_UUID,ITEM_TITLE
* deleteItem(ITEM_UUID,PARENT_UUID)
	* If the file "data/ITEM_UUID" exists
		* For each line in "structure/index.log" with ITEM_UUID as PARENT_UUID
			* call deleteItem recursively
		* Add on "structure/index.log" a line DE,ITEM_UUID,PARENT_UUID
* listChildren(ITEM_UUID)
	* Find on "structure/index.log" all the lines with ITEM_UUID as PARENT_UUID
		* For each founded line take only the most recent
		* For each founded line retrieve the ITEM_TITLE
		* Return a list of object in format {"title":"ITEM_TITLE","id":"ITEM_ID"}
* getContent(ITEM_UUID)
	* Return the content of the file "data/ITEM_UUID"
</step>

### RES 001

I'll create the FlatStorage class according to your requirements. This class will manage file and directory operations using log files as indexes for the structure.

```php
<?php

class FlatStorage {
    private string $dataDir;
    private string $structureDir;
    private string $indexLogPath;
    private string $namesLogPath;
    private string $rootUuid = '00000000-0000-0000-0000-000000000000';
    private string $rootName = 'Root';

    /**
     * Constructor
     */
    public function __construct(string $baseDir = 'data') {
        $this->dataDir = $baseDir;
        $this->structureDir = $baseDir . '/structure';
        $this->indexLogPath = $this->structureDir . '/index.log';
        $this->namesLogPath = $this->structureDir . '/names.log';

        // Ensure directories exist
        if (!file_exists($this->dataDir)) {
            mkdir($this->dataDir, 0755, true);
        }
        if (!file_exists($this->structureDir)) {
            mkdir($this->structureDir, 0755, true);
        }

        // Initialize log files if they don't exist
        if (!file_exists($this->indexLogPath)) {
            file_put_contents($this->indexLogPath, '');
        }
        if (!file_exists($this->namesLogPath)) {
            file_put_contents($this->namesLogPath, '');
        }
    }

    /**
     * Create or update an item
     */
    public function upsertItem(string $itemUuid, string $parentUuid, string $itemTitle, string $itemContent): void {
        $itemPath = $this->dataDir . '/' . $itemUuid;
        
        // Create or update the file content
        file_put_contents($itemPath, $itemContent);
        
        if (!file_exists($itemPath . '.tmp')) {
            // New item - add creation entries
            file_put_contents($this->indexLogPath, "CR,$itemUuid,$parentUuid\n", FILE_APPEND);
            file_put_contents($this->namesLogPath, "CR,$itemUuid,$itemTitle\n", FILE_APPEND);
            // Create a tmp file to mark item as existing
            file_put_contents($itemPath . '.tmp', '');
        } else {
            // Existing item - check for parent change
            $lastParent = $this->getLastParent($itemUuid);
            if ($lastParent !== $parentUuid) {
                file_put_contents($this->indexLogPath, "MV,$itemUuid,$parentUuid\n", FILE_APPEND);
            }
            
            // Check for name change
            $lastName = $this->getLastName($itemUuid);
            if ($lastName !== $itemTitle) {
                file_put_contents($this->namesLogPath, "RN,$itemUuid,$itemTitle\n", FILE_APPEND);
            }
        }
    }

    /**
     * Delete an item and its children recursively
     */
    public function deleteItem(string $itemUuid, string $parentUuid): void {
        // Prevent deleting root
        if ($itemUuid === $this->rootUuid) {
            throw new InvalidArgumentException('Cannot delete root item');
        }
        
        $itemPath = $this->dataDir . '/' . $itemUuid;
        
        if (file_exists($itemPath) || file_exists($itemPath . '.tmp')) {
            // Delete all children recursively
            $children = $this->listChildren($itemUuid);
            foreach ($children as $child) {
                $this->deleteItem($child['id'], $itemUuid);
            }
            
            // Add deletion entry
            file_put_contents($this->indexLogPath, "DE,$itemUuid,$parentUuid\n", FILE_APPEND);
            
            // Remove the tmp marker file
            if (file_exists($itemPath . '.tmp')) {
                unlink($itemPath . '.tmp');
            }
            
            // Remove the actual file
            if (file_exists($itemPath)) {
                unlink($itemPath);
            }
        }
    }

    /**
     * List all children of a specific parent
     */
    public function listChildren(string $parentUuid): array {
        $result = [];
        $indexLines = file($this->indexLogPath, FILE_IGNORE_NEW_LINES);
        
        if ($parentUuid === $this->rootUuid && empty($indexLines)) {
            return $result;
        }
        
        $latestItemStatus = [];
        
        // Process index file to find the latest status of each item
        if ($indexLines) {
            foreach ($indexLines as $line) {
                $parts = explode(',', $line);
                if (count($parts) === 3) {
                    list($action, $itemUuid, $itemParent) = $parts;
                    
                    if ($action === 'CR' || $action === 'MV') {
                        $latestItemStatus[$itemUuid] = [
                            'parent' => $itemParent,
                            'exists' => true
                        ];
                    } elseif ($action === 'DE') {
                        $latestItemStatus[$itemUuid]['exists'] = false;
                    }
                }
            }
        }
        
        // Find children with specified parent
        $childrenIds = [];
        foreach ($latestItemStatus as $itemUuid => $status) {
            if ($status['parent'] === $parentUuid && $status['exists']) {
                $childrenIds[] = $itemUuid;
            }
        }
        
        // Get names for each child
        foreach ($childrenIds as $childId) {
            $title = $this->getLastName($childId);
            $result[] = [
                'id' => $childId,
                'title' => $title
            ];
        }
        
        return $result;
    }

    /**
     * Get content of a specific item
     */
    public function getContent(string $itemUuid): string {
        if ($itemUuid === $this->rootUuid) {
            return '';
        }
        
        $itemPath = $this->dataDir . '/' . $itemUuid;
        
        if (file_exists($itemPath)) {
            return file_get_contents($itemPath);
        }
        
        return '';
    }

    /**
     * Get the last known parent of an item
     */
    private function getLastParent(string $itemUuid): ?string {
        $lines = file($this->indexLogPath, FILE_IGNORE_NEW_LINES);
        $lastParent = null;
        
        if ($lines) {
            for ($i = count($lines) - 1; $i >= 0; $i--) {
                $parts = explode(',', $lines[$i]);
                if (count($parts) === 3 && $parts[1] === $itemUuid) {
                    if ($parts[0] === 'CR' || $parts[0] === 'MV') {
                        $lastParent = $parts[2];
                        break;
                    }
                }
            }
        }
        
        return $lastParent;
    }

    /**
     * Get the last known name of an item
     */
    private function getLastName(string $itemUuid): string {
        if ($itemUuid === $this->rootUuid) {
            return $this->rootName;
        }
        
        $lines = file($this->namesLogPath, FILE_IGNORE_NEW_LINES);
        $lastName = '';
        
        if ($lines) {
            for ($i = count($lines) - 1; $i >= 0; $i--) {
                $parts = explode(',', $lines[$i]);
                if (count($parts) === 3 && $parts[1] === $itemUuid) {
                    if ($parts[0] === 'CR' || $parts[0] === 'RN') {
                        $lastName = $parts[2];
                        break;
                    }
                }
            }
        }
        
        return $lastName;
    }
}
```

This implementation:

1. Uses two log files to track structure and names of items
2. Handles the root item as a special case
3. Implements the four main methods: upsertItem, deleteItem, listChildren, and getContent
4. Uses temporary files to track item existence efficiently
5. Includes helper methods to get the last known parent and name of items
6. Properly handles cases like recursive deletion of items

The class follows a simple append-only log approach where operations are recorded sequentially, and the current state is determined by replaying these operations.